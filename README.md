# Project Documentation

This documentation provides an overview of various sorting and searching algorithms along with their specifications, complexities, explanations, and code examples.

## Algorithms

### Binary Search

**Background Image:**
![Binary Search](bgSearchlight.jpg)

**Specifications:**
- Binary Search is an efficient searching algorithm used to find a specific element in a sorted list of elements.
- Algorithm Paradigm: Binary Search
- Time Complexity: O(log n)
- Space Complexity: O(1)

**Complexity:**
- Time Complexity: O(log n)
- Space Complexity: O(1)

**Explanation:**
Binary Search works by dividing the sorted list into two halves and compares the middle element with the target element. If the middle element is equal to the target, the search is successful...

**Code Examples:**
- [C Code](Assets/code/BinarySearch.c)
- [Java Code](Assets/code/BinarySearch.java)
- [Python Code](Assets/code/Binarysearch.py)

### Bubble Sort

**Background Image:**
![Bubble Sort](bgSort.jpg)

**Specifications:**
- Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.
- Algorithm Paradigm: Bubble Sort
- Sorting in Place: Yes
- Stable: Yes

**Complexity:**
- Best Case: O(n)
- Average Case: O(n^2)
- Worst Case: O(n^2)
- Space Complexity: O(1)

**Explanation:**
Bubble Sort works by repeatedly stepping through the list of elements to be sorted and comparing adjacent elements...

**Code Examples:**
- [C Code](Assets/code/Bubblesort.c)
- [Java Code](Assets/code/Bubblesort.java)
- [Python Code](Assets/code/Bubblesort.py)

... (repeat similar sections for other algorithms)

## Usage

To use the provided algorithms, follow these steps:

1. Select the algorithm you want to use from the list.
2. Click on the "Run" button to execute the algorithm.
3. ...

## Conclusion

This project provides a comprehensive overview of various sorting and searching algorithms along with their specifications, complexities, explanations, and code examples. By understanding these algorithms, developers can make informed decisions about which algorithm to use for different scenarios.
